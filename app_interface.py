import os
import json
import re
from datetime import datetime
import streamlit as st
from main import prompts, model, conversation_log
from main import question_chain_th, question_chain_en, summary_chain_th, summary_chain_en

with open("season_blessings.json", "r", encoding="utf-8") as f:
    SEASON_BLESSINGS = json.load(f)

def extract_question_only(text):
    matches = re.findall(r"([^?.!]{5,200}\?)", text)
    return matches[0].strip() if matches else text.strip()

def extract_top_season(score_text):
    season_scores = {}
    for line in score_text.splitlines():
        match = re.match(r"(‡∏§‡∏î‡∏π.+?\(.*?\)):\s*([0-9]+)", line)
        if match:
            season = match.group(1).strip()
            score = int(match.group(2))
            season_scores[season] = score
    top_season = max(season_scores.items(), key=lambda x: x[1])[0] if season_scores else ""
    return season_scores, top_season

def run_interactive_conversation(num_questions=8):
    st.title("üí¨ Chat with a Personality Analysis AI")
    st.markdown("Please answer each question honestly to help the AI figure out your true season more accurately!")

    if "step" not in st.session_state:
        st.session_state.step = 0
        st.session_state.history = []
        st.session_state.user_inputs = []
        st.session_state.finished = False
        st.session_state.confirmed_end = False
        st.session_state.awaiting_question = True

    # Show Questions
    if not st.session_state.confirmed_end:
        if st.session_state.awaiting_question:
            if st.session_state.step == 0:
                st.session_state.model_question_th = "‡∏ñ‡πâ‡∏≤‡∏ï‡πâ‡∏≠‡∏á‡∏ô‡∏¥‡∏¢‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏à‡∏∞‡∏ô‡∏¥‡∏¢‡∏≤‡∏°‡∏ï‡∏±‡∏ß‡πÄ‡∏≠‡∏á‡∏ß‡πà‡∏≤‡∏≠‡∏¢‡πà‡∏≤‡∏á‡πÑ‡∏£?"
                st.session_state.model_question_en = "If you had to define yourself in one sentence, what would it be?"
                st.session_state.model_prompt_th = "‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô"
                st.session_state.model_prompt_en = "Initial question without history"
            else:
                context = "\n".join([f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {x}" for x in st.session_state.user_inputs])
                full_th = question_chain_th.invoke({"context": context}).strip()
                full_en = question_chain_en.invoke({"context": context}).strip()
                st.session_state.model_question_th = extract_question_only(full_th)
                st.session_state.model_question_en = extract_question_only(full_en)
                st.session_state.model_prompt_th = prompts["question_th"].replace("{context}", context)
                st.session_state.model_prompt_en = prompts["question_en"].replace("{context}", context)

            st.session_state.awaiting_question = False  # ‡∏£‡∏≠‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏Å‡πà‡∏≠‡∏ô‡∏à‡∏∞‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏£‡∏≠‡∏ö‡πÉ‡∏´‡∏°‡πà

        st.markdown(f"<h3>‚ùì ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏ó‡∏µ‡πà {st.session_state.step + 1}</h3>", unsafe_allow_html=True)
        st.markdown(f"<p style='font-size: 20px;'>‚ùì <b>‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° (TH):</b> {st.session_state.model_question_th}</p>", unsafe_allow_html=True)
        st.markdown(f"<p style='font-size: 18px;'>üåê <b>Question (EN):</b> {st.session_state.model_question_en}</p>", unsafe_allow_html=True)

        user_input = st.chat_input("‡∏û‡∏¥‡∏°‡∏û‡πå‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì ‡πÅ‡∏•‡πâ‡∏ß‡∏Å‡∏î Enter")
        if user_input:
            timestamp = datetime.now().isoformat()
            st.session_state.history.append({
                "timestamp": timestamp,
                "model_prompt": st.session_state.model_prompt_th,
                "model_prompt_en": st.session_state.model_prompt_en,
                "model_question_th": st.session_state.model_question_th,
                "model_question_en": st.session_state.model_question_en,
                "user_answer": user_input.strip()
            })

            st.session_state.user_inputs.append(user_input.strip())
            st.session_state.step += 1
            st.session_state.awaiting_question = True

            if st.session_state.step >= num_questions:
                st.session_state.finished = True
            st.rerun()
            st.stop()

        if st.session_state.finished and not st.session_state.confirmed_end:
            if st.button("üîç ‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå"):
                st.session_state.confirmed_end = True
                st.rerun()

    if st.session_state.finished and st.session_state.confirmed_end:
        context = "\n".join([f"‡∏ú‡∏π‡πâ‡πÉ‡∏ä‡πâ: {x}" for x in st.session_state.user_inputs])
        summary_th = summary_chain_th.invoke({"context": context}).strip()
        summary_en = summary_chain_en.invoke({"context": context}).strip()

        score_prompt = prompts["season_scores"].replace("{context}", context)
        season_scores_text = model.invoke(score_prompt).strip()
        season_scores, top_season = extract_top_season(season_scores_text)

        summary_th += f"\n\nüå§Ô∏è ‡∏§‡∏î‡∏π‡∏ó‡∏µ‡πà‡∏™‡∏≠‡∏î‡∏Ñ‡∏•‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ö‡∏ö‡∏∏‡∏Ñ‡∏•‡∏¥‡∏Å‡∏†‡∏≤‡∏û‡∏°‡∏≤‡∏Å‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î: **{top_season}**"

        conversation_log["conversation"] = st.session_state.history
        conversation_log["summary"] = summary_th
        conversation_log["summary_en"] = summary_en
        conversation_log["season_scores"] = season_scores
        conversation_log["top_season"] = top_season

        st.subheader("üéØ ‡∏§‡∏î‡∏π‡πÄ‡∏î‡πà‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î (Top Season):")
        st.success(top_season)

        image_path = f"img/{top_season}.png"
        if os.path.exists(image_path):
            st.image(image_path, caption=f"üå∏ ‡∏ö‡∏∏‡∏Ñ‡∏•‡∏¥‡∏Å‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡∏Ñ‡∏∑‡∏≠ {top_season}", use_container_width=True)
        else:
            st.warning(f"üîç ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏†‡∏≤‡∏û‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏§‡∏î‡∏π: {top_season}")

        if top_season in SEASON_BLESSINGS:
            st.markdown(f"""
            <div style="
                background-color: #1a1d29;
                padding: 20px;
                border-radius: 10px;
                border-left: 6px solid #4ade80;
                color: white;
                font-size: 16px;
                line-height: 1.6;
                margin-top: 1rem;
            ">
            <b>üå∏ Blessing of the Season</b><br><br>
            {SEASON_BLESSINGS[top_season]}
            </div>
            """, unsafe_allow_html=True)

        st.subheader("üß† Personality Summary (English):")
        st.info(summary_en)

        st.markdown("""
        <div style="
            background-color: #1a1d29;
                padding: 20px;
                border-radius: 10px;
                border-left: 6px solid ##5ec7f7;
                color: white;
                font-size: 16px;
                line-height: 1.6;
                margin-top: 1rem;
        ">
        <b>üöÄ ‡∏ä‡πà‡∏ß‡∏¢‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡∏ó‡∏≥‡πÅ‡∏ö‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡πÉ‡∏´‡πâ‡∏´‡∏ô‡πà‡∏≠‡∏¢‡∏ô‡∏∞‡∏Ñ‡∏£‡∏±‡∏ö üçÇüß†üåå</b><br><br>
        üëâ <a href="https://forms.gle/rcAerFKr7uimAGiY6" target="_blank"> Click Here üåü‚ú®</a>
        </div>
        """, unsafe_allow_html=True)

        st.divider()

        st.subheader("üå∏ ‡∏Ñ‡∏∞‡πÅ‡∏ô‡∏ô‡∏§‡∏î‡∏π (Season Scores):")
        for season, score in season_scores.items():
            st.markdown(f"- **{season}**: {score}")

        st.divider()
        st.subheader("üïò ‡∏õ‡∏£‡∏∞‡∏ß‡∏±‡∏ï‡∏¥‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°-‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á")
        for entry in st.session_state.history:
            st.markdown(f"**‚ùì {entry['model_question_th']}**")
            st.markdown(f"üí¨ _{entry['user_answer']}_")

        # Save
        filename = "conversation_log.json"
        all_logs = []
        if os.path.exists(filename):
            with open(filename, "r", encoding="utf-8") as f:
                try:
                    existing_data = json.load(f)
                    all_logs = [existing_data] if isinstance(existing_data, dict) else existing_data
                except json.JSONDecodeError:
                    all_logs = []

        all_logs.append(conversation_log)
        with open(filename, "w", encoding="utf-8") as f:
            json.dump(all_logs, f, ensure_ascii=False, indent=2)

        st.success("üìÅ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÅ‡∏•‡πâ‡∏ß‡∏ó‡∏µ‡πà: conversation_log.json")

run_interactive_conversation()
